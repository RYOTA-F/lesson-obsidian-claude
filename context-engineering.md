# コンテキストエンジニアリング

AI （[Claude Code](../claude-code/README.md)、Cursor、Windsurf など）の潜在能力を最大限に引き出すための技術

## **コンテキストエンジニアリング**とは

現在利用されている AI エディター（Cursor、Claude Code、Codex など）といった AI コーディングエージェントの潜在能力を**10 倍、20 倍に引き上げる**ことができる考え方です。

AI コーディングエージェントの裏側では LLM（大規模言語モデル。Claude のモデルや GPT のモデルなど）が利用されており、これらの LLM には、人間の記憶領域のような**コンテキストウィンドウ**が設定されています。

### **コンテキストウィンドウの限界:**

これは LLM が記憶できる限界を定めています。例えば、Claude Code の一般ユーザーの場合、コンテキストウィンドウの大きさは**20 万トークン**が限界として定められています。

### **コンテキストウィンドウの内容:**

この記憶領域には、私たちがプロンプトで指示する**ユーザーインプット**（ユーザーメッセージ）、AI がコード編集やファイル検索などに利用する**ツール**、そして最終的な**アウトプット**（AI のエージェントからのメッセージ）がすべて含まれます。

### **コンテキスト管理の必要性**

LLM はコンテキストウィンドウの範囲内で動作するため、会話が繰り返されてウィンドウが溢れると、**過去の履歴（記憶）が抜け落ちてしまいます**。その結果、AI が同じような実装を繰り返したり、避けるべき関数を再度使ってしまうといった問題が起こります。特に中規模・大規模なプロジェクトにおいては、AI の記憶領域（コンテキスト）を開発者が管理し、その状態を把握することが非常に重要になります。

2. コンテキストエンジニアリングの 4 つの原則

LangChain の公式ブロックで解説されているコンテキストエンジニアリングがうまくいくための**4 つの原則**があります。

1. ライト（記述 / Write）

これは**外部メモ**に関する原則です。コンテキストウィンドウの記憶容量だけではアプリケーションの概要を管理しきれないため、AI が忘れないように、**外部ドキュメント（ドックス）**として情報を管理します。 具体的には、要件定義書、仕様書、最新のドキュメント、**タスク管理用チケットファイル**（進捗管理に非常に重要）、および守ってほしいルールなどをマークダウンファイルなどで外部記憶として残します。

2. セレクト（選択 / Select）

これは、**適切なタイミングで、外部メモに記述された適切なファイル（ドキュメント）を AI に読み込ませる**技術です。例えば、AI の出力精度が悪くなってきた時などに、再度参照させることが推奨されます。

3. コンプレス（圧縮 / Compress）

コンテキストの残りが少なくなってきた時に、**会話履歴を圧縮・要約する**ことです。Claude Code には**オートコンパクト機能**が備わっており、バッファー（予備領域）に達すると自動的に発動するため、開発者が常に意識する必要はあまりありません。手動で圧縮することも可能です。

4. アイソレート（分離 / Isolate）

これは**コンテキストの分離**を意味します。 **サブエージェント**を利用することで、メインのエージェントとは**独立したコンテキスト**で作業をさせることができます。これにより、メインのコンテキストを圧迫することなく（**コンテキスト汚染や圧迫を防ぐ**）、サブエージェントが作業を行い、結果を要約してメインコンテキストに返すことが可能になります。サブエージェントは、パフォーマンス改善やセキュリティ改善、あるいはデザイン調査など、特定の目的のために作成されます。

3. スペック駆動開発との関連

「ライト（記述）」と「セレクト（選択）」の原則を満たす開発手法として、**スペック駆動開発**（使用書駆動開発、ドキュメント駆動開発とも呼ばれる）が推奨されています。 これは、開発を始める前に要件定義や使用書をしっかり固めておくという進め方です。この手法を用いることで、LLM が開発しやすい環境を整えることができます。

## **補足ツール** コンテキストの状態を把握するためには、Claude Code などで`/context`コマンドを使用し、メッセージやツールの利用がコンテキストをどの程度圧迫しているか（リソースの状態）を定期的に確認することが推奨されています。

https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents

https://blog.langchain.com/context-engineering-for-agents/

https://zenn.dev/farstep/articles/context-engineering

1. コンテキストの基礎と管理の必要性

LLM（大規模言語モデル）は、**CPU**に、その**コンテキストウィンドウ**はモデルの**ワーキングメモリ（RAM）**に例えられます。このコンテキストウィンドウには容量の限界があり、様々なコンテキストソースを処理するための限られた能力しかありません。

**管理すべきコンテキストの種類** LLM アプリケーション構築において管理が必要なコンテキストには、以下の種類があります。

• **指示 (Instructions):** プロンプト、記憶、フューショット（few-shot）の例、ツール説明など。

• **知識 (Knowledge):** 事実、記憶など。

• **ツール (Tools):** ツール呼び出しからのフィードバック。

**コンテキスト管理の課題** エージェントは LLM の呼び出しとツール呼び出しを交互に行い、長期にわたるタスクを遂行します。この際、ツール呼び出しからのフィードバックが蓄積されると、大量のトークンを消費し、以下の問題を引き起こす可能性があります。

• **コンテキストウィンドウのサイズ超過**

• コスト/レイテンシーの増大

• **エージェントのパフォーマンスの低下**。具体的な低下要因として、「ハルシネーションがコンテキストに混入する**コンテキスト汚染**」「不要なコンテキストが応答に影響する**コンテキスト混乱**」「コンテキストの一部が矛盾する**コンテキストクラッシュ**」などが挙げられています。

2. コンテキストエンジニアリングの 4 つの主要戦略

エージェントのコンテキスト管理の課題に対処するため、共通して採用されている戦略は、**Write (記述)、Select (選択)、Compress (圧縮)、Isolate (分離)** の 4 つのカテゴリーに分類されます。

1. Write (記述)

**定義:** エージェントがタスクを実行できるように、**コンテキストウィンドウの外に情報を保存する**こと。

• **スクラッチパッド (Scratchpads):** 人間がタスクを解く際にメモを取るように、エージェントがタスク実行中に情報をファイルなどに書き込み、コンテキストウィンドウの外に情報を永続化するアプローチです。

• **長期記憶 (Memories):** 複数のセッションを超えてエージェントが情報を記憶すること。ChatGPT、Cursor、Windsurf などの人気製品には、ユーザーとエージェントのやり取りに基づき、セッション間で持続する長期記憶を自動生成するメカニズムがあります。

2. Select (選択)

**定義:** エージェントがタスクを実行できるように、**外部に保存されたコンテキストをコンテキストウィンドウ内に取り込む**こと。

• **記憶の選択:** エージェントは、望ましい行動の例（エピソード記憶）、行動を誘導する指示（手続き記憶）、またはタスクに関連する事実（セマンティック記憶）を選択することができます。

• **RAG (Retrieval Augmented Generation) 技術:** 大量の知識やコードベースから、関連性の高い情報やツール説明のみを検索して取り込むのに RAG が使用されます。埋め込み（Embeddings）やナレッジグラフが、記憶のインデックス作成によく用いられます。

• **ツール選択の改善:** ツールが多すぎるとモデルが混乱するため、RAG をツールの説明に適用し、タスクに最も関連性の高いツールのみを取り出すことで、ツールの選択精度を改善する手法もあります。

3. Compress (圧縮)

**定義:** タスクを実行するために**必要とされるトークンのみを保持する**こと。

• **コンテキスト要約 (Context Summarization):** 数百ターンに及ぶエージェントのやり取りや、トークン負荷の高いツール呼び出しを管理する一般的な方法です。Claude Code では、コンテキストウィンドウが 95%を超えた後、ユーザーとエージェントのやり取りの履歴全体を要約する「オートコンパクト」機能が実行されます。

• **コンテキスト刈り込み (Context Trimming):** LLM を使わずに、ハードコードされたヒューリスティック（例：リストから古いメッセージを削除）などを用いてコンテキストをフィルタリングする手法です。

4. Isolate (分離)

**定義:** エージェントがタスクを実行できるように、**コンテキストを分割する**こと。

• **マルチエージェント/サブエージェント:** コンテキストをサブエージェント間で分割することが最も一般的な分離方法です。各サブエージェントは固有のツール、指示、および**自身のコンテキストウィンドウ**を持ち、より狭いサブタスクにコンテキストを割り当てることができます。

• **環境による隔離 (Sandboxes):** ツール呼び出し（特にトークン負荷の高いオブジェクト）の結果をサンドボックスやランタイム状態オブジェクト内に保存し、LLM から隔離することで、コンテキストの汚染を防ぎます。

• **状態オブジェクト (State):** エージェントのランタイム状態オブジェクトを利用し、ツール呼び出しからのコンテキストなどを特定のフィールドに保存することで、そのコンテキストが要求されるまで LLM から隔離できます。

3. LangGraph と LangSmith による実装サポート

• **LangGraph:** 上記の 4 つの原則をサポートするように設計されています。チェックポイント機能により短期記憶（スクラッチパッド）として状態の永続化をサポートし、「Write」を容易にします。また、ノードごとに状態（コンテキスト）を取り込むことができ、「Select」においてきめ細かな制御を提供します。さらに、ノード間のロジック制御や状態オブジェクトにより、「Compress」や「Isolate」も容易に実装できます。

• **LangSmith:** エージェントの実行トレーシングやトークン使用量の追跡、性能評価を提供し、コンテキストエンジニアリングの取り組みの成果をテストし、どこに労力を集中すべきかを判断するのに役立ちます。

---

## 関連

- [serena](../mcp/serena.md) - Isolation and memory principles
- [command](../claude-code/command.md) - Implementation tool for context principles
- [nestjs](../../knowledge-dev/backend/nestjs/nestjs.md) - Large codebase management

## 参考リンク
