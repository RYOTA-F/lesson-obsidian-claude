# AI ファーストのマークダウン

## 概要

AI 時代において、マークダウンは単なる文書フォーマットから「AI との対話インターフェース」へと進化している。LLM が理解しやすい構造化された情報を提供することで、より正確で効率的な AI 支援を実現する。

## なぜマークダウンが AI 時代に重要か

### 1. 構造化された情報の提供

- **階層構造の明確化**: 見出しレベル(`#`, `##`, `###`)でコンテキストの重要度を示す
- **意味的セクション分割**: AI が文脈を理解しやすい単位で情報を整理
- **メタデータの埋め込み**: フロントマターやタグでドキュメント属性を定義

### 2. LLM の理解効率の向上

- マークダウンは LLM の訓練データに大量に含まれており、解釈精度が高い
- プレーンテキストより 30-50%少ないトークンで同等の情報を伝達可能
- 構造化により、関連情報の抽出・検索が高速化

### 3. 人間と AI の共通言語

- 人間が読みやすく、同時に AI が解析しやすい
- バージョン管理(Git)との親和性が高い
- エディタ、IDE、ナレッジベースツール全てでサポート

## コンテキストエンジニアリングのためのマークダウン設計原則

### 原則 1: 明示的な階層構造

```markdown
# プロジェクト概要 (最上位コンテキスト)

## 目的 (主要セクション)

### ビジネス目標 (詳細レベル)

#### KPI 定義 (実装レベル)
```

**理由**: LLM は見出しレベルで情報の重要度と関係性を判断する

### 原則 2: セマンティックなセクション名

```markdown
❌ 悪い例:

## その他

## メモ

## TODO

✅ 良い例:

## アーキテクチャ上の制約

## 既知の技術的負債

## 次期スプリントの実装タスク
```

**理由**: 具体的なセクション名がコンテキストの意図を明確にする

### 原則 3: リストによる構造化

```markdown
## 機能要件

- **認証機能**
  - ユーザー登録: メール認証必須
  - ログイン: JWT トークン方式
  - パスワードリセット: メールリンク経由
- **権限管理**
  - ロールベースアクセス制御(RBAC)
  - 3 つのロール: Admin, Editor, Viewer
```

**理由**: 箇条書きで関係性と優先度を明確化

### 原則 4: コードブロックの適切な使用

````markdown
```typescript
// ❌ 悪い例: 言語指定なし
function getData() { ... }
```

```typescript
// ✅ 良い例: 言語指定 + コメント
/**
 * ユーザーデータを取得する
 * @param userId - ユーザーID
 * @returns ユーザーオブジェクト
 */
async function getUserData(userId: string): Promise<User> {
  // 実装詳細
}
```
````

**理由**: 言語指定でシンタックス理解を向上、コメントでコンテキスト補完

### 原則 5: テーブルによる比較情報

```markdown
## アプローチ比較

| アプローチ | メリット     | デメリット     | 推奨ケース       |
| ---------- | ------------ | -------------- | ---------------- |
| REST API   | シンプル     | Over-fetching  | CRUD 操作        |
| GraphQL    | 柔軟なクエリ | 複雑性増加     | 複雑なデータ関係 |
| gRPC       | 高速         | ブラウザ非対応 | マイクロサービス |
```

**理由**: 表形式で構造化された比較データは LLM が解析しやすい

## AI 時代のマークダウンパターン

### パターン 1: コンテキストレイヤー構造

```markdown
# プロジェクト名

## 🎯 ビジネスコンテキスト

- 解決する課題
- ターゲットユーザー
- 成功指標

## 🏗️ 技術コンテキスト

- アーキテクチャ概要
- 技術スタック
- 設計原則

## 📋 実装コンテキスト

- 現在の実装状態
- 既知の課題
- 次のステップ
```

**効果**: LLM が適切なレベルのコンテキストを選択可能

### パターン 2: 意思決定記録(ADR)形式

```markdown
## 決定: GraphQL 採用

**ステータス**: 承認済み
**日付**: 2025-01-15
**決定者**: 開発チーム

### コンテキスト

複数のフロントエンドから異なるデータ形式が要求される

### 検討した選択肢

1. REST API - シンプルだが柔軟性に欠ける
2. GraphQL - 学習コスト高いが長期的に効率的
3. BFF パターン - 実装コスト大

### 決定

GraphQL を採用

### 理由

- フロントエンドチームの自律性向上
- Over-fetching/Under-fetching の解消
- 型安全性の確保

### 影響

- バックエンド開発に 2 週間の学習期間必要
- 既存 REST API は段階的に移行
```

**効果**: 過去の意思決定背景を LLM が理解し、一貫性のある提案が可能

### パターン 3: タスク指向マークダウン

````markdown
## タスク: ユーザー認証実装

### 前提条件

- [ ] データベーススキーマ設計完了
- [x] JWT ライブラリ選定済み(jsonwebtoken)
- [ ] フロントエンド認証フロー設計

### 実装ステップ

1. **バックエンド**
   ```typescript
   // POST /api/auth/register
   // POST /api/auth/login
   // POST /api/auth/refresh
   ```
````

2. **ミドルウェア**
   - JWT 検証ミドルウェア
   - 権限チェックミドルウェア
3. **テスト**
   - ユニットテスト: 認証ロジック
   - 統合テスト: API エンドポイント

### 完了条件

- [ ] 全エンドポイントが 200/401 を適切に返す
- [ ] テストカバレッジ >90%
- [ ] セキュリティレビュー完了

````

**効果**: LLMがタスクの進捗と次のアクションを正確に把握

### パターン4: 関連リンクによるナレッジグラフ

```markdown
# GraphQL実装ガイド

## 概要
GraphQLサーバーの実装パターンと最適化手法

## 関連
- [NestJS](../backend/nestjs.md) - フレームワーク統合
- [TypeScript](../language/typescript.md) - 型定義パターン
- [API設計](../architecture/api-design.md) - 設計原則
- [パフォーマンス最適化](../performance/optimization.md) - クエリ最適化
- [セキュリティ](../security/graphql-security.md) - 攻撃対策

## 前提知識
- [REST API基礎](../api/rest-basics.md)
- [スキーマ設計](./schema-design.md)
````

**効果**: LLM が関連コンテキストを自動的に収集し、包括的な理解を構築

## ツール別マークダウン最適化

### Obsidian 向け最適化

```markdown
---
tags: [ai, graphql, backend]
aliases: [GQL実装, GraphQL実装]
created: 2025-01-15
updated: 2025-01-20
---

# GraphQL 実装ガイド

## リンク設定

- **Obsidian リンク**: `[ファイル名](path/to/file.md)` (Markdown リンク)
- **タグ**: `#ai/コンテキストエンジニアリング`
- **バックリンク**: 自動生成されるため明示的な記述不要

## プラグイン活用

- **Dataview**: メタデータクエリ
- **Graph View**: ナレッジグラフ可視化
```

### Notion 向け最適化

```markdown
# データベース連携

## プロパティ定義

- **ステータス**: 選択式(計画中/進行中/完了)
- **優先度**: 数値(1-5)
- **タグ**: マルチセレクト
- **関連ページ**: リレーション

## 埋め込みコンテンツ

- コードブロック: シンタックスハイライト対応
- 数式: KaTeX 記法サポート
```

### VSCode + Claude Code 向け最適化

````markdown
# プロジェクトコンテキスト

## ファイル参照

- **相対パス**: [auth.ts](src/auth/auth.ts)
- **行番号**: [auth.ts:42](src/auth/auth.ts#L42)
- **範囲指定**: [auth.ts:42-51](src/auth/auth.ts#L42-L51)

## 実行可能コードブロック

```bash
# 開発サーバー起動
npm run dev

# テスト実行
npm test -- --coverage
```
````

## CLAUDE.md パターン

- グローバル指示: `~/.claude/CLAUDE.md`
- プロジェクト指示: `.claude/CLAUDE.md`

````

## LLMトークン効率化テクニック

### テクニック1: シンボル記法の活用

```markdown
## ステータス概要
✅ 完了: 認証API実装
🔄 進行中: 権限管理
⏳ 予定: 監査ログ
❌ ブロック中: LDAP統合(依存ライブラリ未選定)
````

**効果**: テキストより 30-40%トークン削減

### テクニック 2: テーブルによる圧縮

```markdown
## API エンドポイント

| メソッド | パス           | 説明         | 認証        |
| -------- | -------------- | ------------ | ----------- |
| POST     | /auth/register | 登録         | 不要        |
| POST     | /auth/login    | ログイン     | 不要        |
| GET      | /users/:id     | ユーザー取得 | 必須        |
| PUT      | /users/:id     | ユーザー更新 | 必須 + 本人 |
```

**効果**: 構造化により情報密度が向上

### テクニック 3: 折りたたみセクション(詳細省略)

```markdown
## 実装詳細

### 概要

JWT 認証を使用した認証システム

<details>
<summary>技術的詳細(クリックで展開)</summary>

- アルゴリズム: RS256
- トークン有効期限: 15 分(アクセス)、7 日(リフレッシュ)
- 保存場所: httpOnly Cookie

</details>
```

**効果**: 必要時のみ詳細をコンテキストに含める

## アンチパターン(避けるべきパターン)

### ❌ アンチパターン 1: 曖昧なセクション名

```markdown
## その他

- いろいろなメモ
- TODO: あとで整理

## 参考

- リンク 1
- リンク 2
```

**問題**: LLM がコンテキストの意図を判断できない

### ❌ アンチパターン 2: 長大な単一セクション

```markdown
## 実装メモ

ユーザー認証について実装を開始した。まず JWT ライブラリを選定し、
次にミドルウェアを作成した。その後エンドポイントを実装し、
テストを書いた。セキュリティレビューも実施し...
(3000 文字の散文が続く)
```

**問題**: 構造化されておらず、情報抽出が困難

### ❌ アンチパターン 3: コードの過剰な引用

````markdown
## 実装コード

```typescript
// 500行の完全なファイル内容をそのまま貼り付け
```
````

**問題**: トークンを無駄に消費、本質的な情報が埋もれる

### ❌ アンチパターン 4: コンテキスト不足のリンク

```markdown
## 参考

- [こちら](https://example.com)
- [詳細](https://docs.example.com)
```

**問題**: リンク先の内容が不明で LLM が判断不可

## 実践例: プロジェクト README

````markdown
# EC サイトリニューアルプロジェクト

## 🎯 プロジェクト概要

- **目的**: レガシーシステムからモダンスタックへの移行
- **期間**: 2025 年 1 月-6 月(6 ヶ月)
- **チーム**: フロントエンド 3 名、バックエンド 2 名、デザイン 1 名

## 🏗️ アーキテクチャ

### 技術スタック

| レイヤー       | 技術             | 理由                           |
| -------------- | ---------------- | ------------------------------ |
| フロントエンド | Next.js 14       | App Router, RSC 活用           |
| バックエンド   | NestJS + GraphQL | 型安全性、柔軟性               |
| データベース   | PostgreSQL       | リレーショナルデータ           |
| インフラ       | Vercel + AWS     | 高速デプロイ、スケーラビリティ |

### システム構成

```text
┌─────────────┐
│  Next.js    │ ← Vercel Edge
├─────────────┤
│  GraphQL    │ ← Apollo Client
├─────────────┤
│  NestJS API │ ← AWS ECS
├─────────────┤
│ PostgreSQL  │ ← AWS RDS
└─────────────┘
```
````

## 📋 実装ステータス

### Phase 1: 基盤構築(完了)

- ✅ プロジェクトセットアップ
- ✅ CI/CD パイプライン
- ✅ 開発環境構築

### Phase 2: コア機能(進行中)

- ✅ ユーザー認証
- 🔄 商品カタログ(80%)
- ⏳ ショッピングカート(未着手)
- ⏳ 決済統合(未着手)

### Phase 3: 最適化(予定)

- パフォーマンス最適化
- SEO 対応
- アクセシビリティ改善

## 🔗 関連ドキュメント

- [アーキテクチャ決定記録](docs/adr/README.md)
- [API 仕様書](docs/api/README.md)
- [フロントエンド実装ガイド](docs/frontend/guide.md)
- [デプロイメントガイド](docs/deployment/guide.md)

## 🚨 既知の課題

1. **パフォーマンス**: 商品一覧の初期読み込みが遅い(3 秒)
   - 原因調査中: N+1 クエリ疑い
   - 優先度: 高
2. **セキュリティ**: CSRF 対策が未実装
   - 優先度: 最高
   - 担当: バックエンドチーム

## 💡 次のアクション

- [ ] CSRF 対策実装(今週中)
- [ ] 商品一覧パフォーマンス調査(来週)
- [ ] ショッピングカート設計レビュー(1/25)

```

## まとめ

### コンテキストエンジニアリング時代のマークダウンの特徴

1. **構造化**: 階層、リスト、テーブルで情報を整理
2. **明示性**: セマンティックなセクション名、詳細なメタデータ
3. **効率性**: シンボル、省略記法でトークン最適化
4. **連結性**: リンクとタグでナレッジグラフを構築
5. **実行可能性**: コードブロック、チェックリストで行動を促進

### 実践のポイント

- **AIを読者として意識**: LLMが理解しやすい構造を優先
- **段階的詳細化**: 概要→詳細の階層構造を維持
- **コンテキストの明示**: 暗黙の前提を排除し、全て明文化
- **継続的更新**: ドキュメントを常に最新の状態に保つ
- **ツール最適化**: 使用するツール(Obsidian, Notion, VSCode)に合わせた記法を選択

### 次のステップ

- [プロンプトエンジニアリング](./prompt-engineering.md) - マークダウンを効果的に活用
- [RAG最適化](./rag-optimization.md) - 検索拡張生成での活用
- [ナレッジベース設計](./knowledge-base-design.md) - 組織的知識管理
```
